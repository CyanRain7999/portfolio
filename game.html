<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <title>å°æ¸¸æˆ | æœˆä¹‹æ£®çš„é»„ç“œæ¶</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="stylesheet" href="style.css" />
</head>
<body>
  <canvas id="bg-canvas"></canvas>

  <header class="site-header">
    <div class="container navbar">
      <a href="index.html" class="logo">æœˆã®æ£®<span>ğŸ¥’</span></a>
      <nav class="nav-links">
        <a href="index.html" class="nav-link">ä¸»é¡µ</a>
        <a href="about.html" class="nav-link">å…³äºæˆ‘</a>
        <a href="projects.html" class="nav-link">é¡¹ç›®</a>
        <a href="contact.html" class="nav-link">è”ç³»</a>
	<a href="game.html" class="nav-link active">å°æ¸¸æˆ</a>
      </nav>
    </div>
  </header>
<main class="container">
    <section>
      <h1 class="section-title">å¼¹å¹•ç»ƒä¹ åœº</h1>
      <p class="section-subtitle">
        æ“ä½œï¼šâ†‘ â†“ â† â†’ ç§»åŠ¨ï¼›<br />
        æŒ‰ä½ <strong>Shift</strong> ä½é€Ÿå¾®è°ƒï¼Œ<strong>Z</strong> è¿å°„ï¼Œ<strong>X</strong> Bomb æ¸…å±ï¼‹çŸ­æš‚æ— æ•Œã€‚
      </p>

      <div class="game-wrapper">
        <!-- ç«–ç‰ˆ STG æ¯”ä¾‹ -->
        <canvas id="game-canvas" width="360" height="480"></canvas>

        <div class="btn-row" style="margin-top: 0.75rem;">
          <button id="start-btn" class="btn btn-primary" type="button">
            å¼€å§‹ / é‡æ¥
          </button>
        </div>

        <p class="section-subtitle" style="margin-top: 0.6rem;">
          å°åœ†ç‚¹å°±æ˜¯ä½ ï¼Œé¡¶éƒ¨é‚£å›¢å…‰æ˜¯æ•Œæœºã€‚<br />
          å­˜æ´»æ—¶é—´è¶Šä¹…è¶Šå¥½ï¼Œæ“¦å¼¹ï¼ˆè´´ç€å¼¹å¹•èµ°ï¼‰ä¼šè®¡æ•°ï¼ŒBomb æ•°æœ‰é™è¦çœç€ç”¨ã€‚
        </p>
      </div>
    </section>
  </main>

  <footer class="site-footer">
    <div class="container">
      Â© 2025 æœˆä¹‹æ£®çš„é»„ç“œæ¶ Â· Bullet Practice
    </div>
  </footer>

  <!-- ç²’å­èƒŒæ™¯ -->
  <script src="particles.js"></script>

  <!-- å¼¹å¹• + è‡ªæœº / æ•Œæœº + Z å°„å‡» + X ç‚¸å¼¹ -->
  <script>
    (function () {
      const canvas = document.getElementById("game-canvas");
      const ctx = canvas.getContext("2d");

      const width = canvas.width;
      const height = canvas.height;

      // è‡ªæœº
      const player = {
        x: width / 2,
        y: height - 70,
        hitRadius: 4,    // åˆ¤å®šç‚¹åŠå¾„
        drawRadius: 9,   // å¤–åœˆæ˜¾ç¤º
        baseSpeed: 3.8,
      };

      // é”®ç›˜çŠ¶æ€ï¼ˆç»Ÿä¸€æ˜ å°„ï¼‰
      const keys = {
        left: false,
        right: false,
        up: false,
        down: false,
        shift: false,
        z: false,
        x: false,
      };

      const keyMap = {
        ArrowLeft: "left",
        ArrowRight: "right",
        ArrowUp: "up",
        ArrowDown: "down",
        Shift: "shift",
        z: "z",
        Z: "z",
        x: "x",
        X: "x",
      };

      // æ•Œæœºï¼ˆboss ç®€åŒ–ç‰ˆï¼‰
      const boss = {
        x: width / 2,
        y: 90,
        radius: 26,
        maxHp: 320,
        hp: 320,
        dir: 1,
        moveSpeed: 0.8,
        phase: 1,
        alive: true,
      };

      // æ•Œæœºå¼¹å¹•ã€è‡ªæœºå­å¼¹
      const enemyBullets = [];
      const playerBullets = [];

      // æ¸¸æˆçŠ¶æ€
      let lastTime = 0;
      let timeAlive = 0;   // å­˜æ´»æ—¶é—´ï¼ˆç§’ï¼‰
      let bestTime = 0;
      let grazes = 0;
      let bestGrazes = 0;
      let playing = false;

      let patternTimer = 0;
      let spiralAngle = 0;

      // è‡ªæœºå°„å‡»å†·å´
      let shootCooldown = 0;

      // æ“¦å¼¹åˆ¤å®šåœˆ
      const grazeRadius = 22;

      // ç‚¸å¼¹
      let bombs = 3;
      let bombActive = false;
      let bombTimer = 0;
      let bombFlash = 0;
      const BOMB_DURATION = 120; // 60fps ä¸‹çº¦ 2 ç§’

      function resetBoss() {
        boss.x = width / 2;
        boss.y = 90;
        boss.radius = 26;
        boss.phase = 1;
        boss.moveSpeed = 0.8;
        boss.maxHp = 320;
        boss.hp = boss.maxHp;
        boss.alive = true;
      }

      function resetGame() {
        player.x = width / 2;
        player.y = height - 70;

        enemyBullets.length = 0;
        playerBullets.length = 0;

        timeAlive = 0;
        grazes = 0;
        patternTimer = 0;
        spiralAngle = 0;
        shootCooldown = 0;

        bombs = 3;
        bombActive = false;
        bombTimer = 0;
        bombFlash = 0;

        resetBoss();
        playing = true;
      }

      // æ•Œæœºå¼¹å¹•ç”Ÿæˆ
      function spawnCirclePattern(cx, cy) {
        const count = 24;
        const baseSpeed = 1.6 + Math.random() * 0.5;
        for (let i = 0; i < count; i++) {
          const angle = (i / count) * Math.PI * 2;
          const speed = baseSpeed + (Math.random() - 0.5) * 0.15;
          enemyBullets.push(createEnemyBullet(cx, cy, angle, speed));
        }
      }

      function spawnFanPattern(cx, cy) {
        const count = 15;
        const spread = Math.PI * 0.8; // æ‰‡å½¢è§’
        const baseAngle = Math.PI / 2; // æœä¸‹
        const baseSpeed = 1.8 + Math.random() * 0.6;

        for (let i = 0; i < count; i++) {
          const t = i / (count - 1) - 0.5;
          const angle = baseAngle + t * spread;
          enemyBullets.push(createEnemyBullet(cx, cy, angle, baseSpeed));
        }
      }

      function spawnSpiralBurst(cx, cy) {
        const speed = 1.9;
        for (let k = 0; k < 3; k++) {
          const offset = (k * Math.PI * 2) / 3;
          const angle = spiralAngle + offset;
          enemyBullets.push(createEnemyBullet(cx, cy, angle, speed));
        }
        spiralAngle += 0.3;
      }

      function createEnemyBullet(cx, cy, angle, speed) {
        const r = 4.5 + Math.random() * 1.8;
        const hue = 190 + Math.random() * 100; // è“é’åˆ°ç²‰ä¸€ç‚¹
        return {
          x: cx,
          y: cy,
          vx: Math.cos(angle) * speed,
          vy: Math.sin(angle) * speed,
          r,
          baseR: r,
          hue,
          alpha: 0.9,
          grazed: false,
        };
      }

      // è‡ªæœºå­å¼¹
      function shootPlayerBullets() {
        const speed = 5.2;
        const spread = 0.12; // åŒå‘å¾®å¾®å¤¹è§’
        const angles = [-spread, spread];

        for (const a of angles) {
          const angle = -Math.PI / 2 + a; // æœä¸Šç•¥å¾®æ•£
          const vx = Math.cos(angle) * speed;
          const vy = Math.sin(angle) * speed;
          playerBullets.push({
            x: player.x,
            y: player.y - 6,
            vx,
            vy,
            r: 3,
            damage: 3,
          });
        }
      }

      function activateBomb() {
        if (!playing || bombs <= 0) return;
        bombs -= 1;
        bombActive = true;
        bombTimer = BOMB_DURATION;
        bombFlash = 1;

        // æ¸…å±ï¼šç›´æ¥æ¸…é™¤æ‰€æœ‰æ•Œæœºå¼¹å¹•
        enemyBullets.length = 0;
      }

      function updateBoss(dt) {
        if (!boss.alive) return;

        // å·¦å³æ…¢æ…¢ç§»åŠ¨
        const moveAmount = boss.moveSpeed * dt;
        boss.x += moveAmount * boss.dir;

        const margin = 40;
        if (boss.x < margin) {
          boss.x = margin;
          boss.dir = 1;
        }
        if (boss.x > width - margin) {
          boss.x = width - margin;
          boss.dir = -1;
        }

        // å¼¹å¹•æ¨¡å¼å®šæ—¶
        patternTimer -= dt;
        if (patternTimer <= 0) {
          const cx = boss.x;
          const cy = boss.y;

          const choice = Math.random();
          if (boss.phase === 1) {
            // æ–°æ‰‹æœŸï¼šåœˆ + æ‰‡å½¢
            if (choice < 0.5) {
              spawnCirclePattern(cx, cy);
              patternTimer = 42;
            } else {
              spawnFanPattern(cx, cy);
              patternTimer = 36;
            }
          } else {
            // ä»¥åç•™ç€æ‰©å±•æ›´éš¾æ¨¡å¼
            if (choice < 0.4) {
              spawnCirclePattern(cx, cy);
              patternTimer = 38;
            } else if (choice < 0.8) {
              spawnFanPattern(cx, cy);
              patternTimer = 30;
            } else {
              spawnSpiralBurst(cx, cy);
              patternTimer = 26;
            }
          }
        } else {
          // å¶å°”æ’å…¥å°‘é‡èºæ—‹æµï¼Œè®©åœºé¢ä¸æ–­æ¡£
          if (patternTimer % 12 < 1.2) {
            spawnSpiralBurst(boss.x, boss.y);
          }
        }
      }

      function update(dt) {
        if (!playing) return;

        const speedFactor = dt; // ä»¥ 60fps ä¸ºåŸºå‡†

        // è‡ªæœºç§»åŠ¨
        let speed = player.baseSpeed * speedFactor;
        if (keys.shift) speed *= 0.45;

        if (keys.left) player.x -= speed;
        if (keys.right) player.x += speed;
        if (keys.up) player.y -= speed;
        if (keys.down) player.y += speed;

        // è¾¹ç•Œçº¦æŸ
        const margin = 12;
        if (player.x < margin) player.x = margin;
        if (player.x > width - margin) player.x = width - margin;
        if (player.y < margin) player.y = margin;
        if (player.y > height - margin) player.y = height - margin;

        // ç‚¸å¼¹è®¡æ—¶
        if (bombTimer > 0) {
          bombTimer -= dt;
          if (bombTimer <= 0) {
            bombTimer = 0;
            bombActive = false;
          }
        }
        if (bombFlash > 0) {
          bombFlash -= dt / BOMB_DURATION;
          if (bombFlash < 0) bombFlash = 0;
        }

        // å­˜æ´»æ—¶é—´
        timeAlive += dt / 60;

        // å°„å‡»å†·å´ & å‘å°„
        if (shootCooldown > 0) {
          shootCooldown -= dt;
        }
        if (keys.z && shootCooldown <= 0) {
          shootPlayerBullets();
          shootCooldown = 6; // çº¦ 0.1s ä¸€æ¬¡
        }

        // æ•Œæœºé€»è¾‘
        updateBoss(dt);

        // æ›´æ–°æ•Œæœºå¼¹å¹•ï¼šç§»åŠ¨ + æ“¦å¼¹ + åˆ¤å®š
        for (const b of enemyBullets) {
          b.x += b.vx * speedFactor;
          b.y += b.vy * speedFactor;

          // å‘¼å¸æ•ˆæœ
          const t = timeAlive * 3;
          b.r = b.baseR * (0.9 + 0.2 * Math.sin(t + b.hue));

          const dx = b.x - player.x;
          const dy = b.y - player.y;
          const dist2 = dx * dx + dy * dy;

          const hitR = player.hitRadius + b.r * 0.8;
          const hitR2 = hitR * hitR;
          const grazeR = grazeRadius + b.r;
          const grazeR2 = grazeR * grazeR;

          if (!bombActive && dist2 < hitR2) {
            // è¢«å‡»ä¸­
            playing = false;
            bestTime = Math.max(bestTime, timeAlive);
            bestGrazes = Math.max(bestGrazes, grazes);
            break;
          }

          if (!b.grazed && dist2 >= hitR2 && dist2 < grazeR2) {
            b.grazed = true;
            grazes += 1;
          }
        }

        // æ¸…ç†é£å‡ºç”»é¢æ•Œæœºå¼¹å¹•
        for (let i = enemyBullets.length - 1; i >= 0; i--) {
          const b = enemyBullets[i];
          if (
            b.x < -50 ||
            b.x > width + 50 ||
            b.y < -80 ||
            b.y > height + 80
          ) {
            enemyBullets.splice(i, 1);
          }
        }

        // æ›´æ–°è‡ªæœºå­å¼¹ + æ‰“ä¸­ boss
        if (boss.alive) {
          for (let i = playerBullets.length - 1; i >= 0; i--) {
            const pb = playerBullets[i];
            pb.x += pb.vx * speedFactor;
            pb.y += pb.vy * speedFactor;

            // å‡ºç•Œ
            if (pb.y < -40 || pb.y > height + 40) {
              playerBullets.splice(i, 1);
              continue;
            }

            // åˆ¤å®šæ‰“ä¸­ boss
            const dx = pb.x - boss.x;
            const dy = pb.y - boss.y;
            const dist2 = dx * dx + dy * dy;
            const r = boss.radius + pb.r;
            if (dist2 < r * r) {
              boss.hp -= pb.damage;
              playerBullets.splice(i, 1);

              if (boss.hp <= 0) {
                boss.alive = false;
                bestTime = Math.max(bestTime, timeAlive);
                bestGrazes = Math.max(bestGrazes, grazes);
              }
            }
          }
        } else {
          // boss æ­»äº†ï¼Œç­‰å‡ ç§’è‡ªåŠ¨å¤æ´»ä¸‹ä¸€è½®
          // è¿™é‡Œå¯ä»¥åšç‚¹æ¼”å‡ºï¼Œç°åœ¨ç®€å•ä¸€ç‚¹ï¼š
          // åœæ­¢å¼¹å¹•ç»§ç»­é£ï¼Œç©å®¶å¯ä»¥æŒ‰å¼€å§‹é‡å¼€ã€‚
        }
      }

      function draw() {
        // èƒŒæ™¯
        const grd = ctx.createLinearGradient(0, 0, 0, height);
        grd.addColorStop(0, "rgba(15,23,42,1)");
        grd.addColorStop(1, "rgba(15,23,42,0.96)");
        ctx.fillStyle = grd;
        ctx.fillRect(0, 0, width, height);

        // åŠé€æ˜é®ç½©ï¼Œåšä¸€ç‚¹æ‹–å°¾æ„Ÿ
        ctx.fillStyle = "rgba(15, 23, 42, 0.16)";
        ctx.fillRect(0, 0, width, height);

        // æ•Œæœº
        if (boss.alive) {
          // å¤–å‘å…‰
          const r = boss.radius * 1.8;
          const g = ctx.createRadialGradient(
            boss.x,
            boss.y,
            0,
            boss.x,
            boss.y,
            r
          );
          g.addColorStop(0, "rgba(251, 113, 133, 0.8)");
          g.addColorStop(1, "rgba(15, 23, 42, 0)");
          ctx.fillStyle = g;
          ctx.beginPath();
          ctx.arc(boss.x, boss.y, r, 0, Math.PI * 2);
          ctx.fill();

          // æœ¬ä½“
          ctx.beginPath();
          ctx.arc(boss.x, boss.y, boss.radius, 0, Math.PI * 2);
          ctx.fillStyle = "rgba(248, 250, 252, 0.95)";
          ctx.fill();

          // ç®€å•â€œçœ¼ç›â€
          ctx.fillStyle = "rgba(15, 23, 42, 0.9)";
          ctx.beginPath();
          ctx.arc(boss.x - 8, boss.y - 4, 3, 0, Math.PI * 2);
          ctx.arc(boss.x + 8, boss.y - 4, 3, 0, Math.PI * 2);
          ctx.fill();
        }

        // æ•Œæœºè¡€æ¡
        if (boss.alive) {
          const barWidth = width - 40;
          const barHeight = 8;
          const x = 20;
          const y = 18;

          ctx.fillStyle = "rgba(15, 23, 42, 0.8)";
          ctx.fillRect(x, y, barWidth, barHeight);

          const ratio = boss.hp / boss.maxHp;
          const innerWidth = barWidth * Math.max(0, Math.min(1, ratio));

          const bg = ctx.createLinearGradient(x, y, x + barWidth, y);
          bg.addColorStop(0, "rgba(251, 113, 133, 0.9)");
          bg.addColorStop(1, "rgba(59, 130, 246, 0.9)");
          ctx.fillStyle = bg;
          ctx.fillRect(x, y, innerWidth, barHeight);

          ctx.strokeStyle = "rgba(148, 163, 184, 0.9)";
          ctx.lineWidth = 1;
          ctx.strokeRect(x + 0.5, y + 0.5, barWidth - 1, barHeight - 1);
        }

        // æ•Œæœºå¼¹å¹•
        for (const b of enemyBullets) {
          const r = b.r * 2;
          const g = ctx.createRadialGradient(
            b.x,
            b.y,
            0,
            b.x,
            b.y,
            r
          );
          g.addColorStop(0, `hsla(${b.hue}, 100%, 75%, ${b.alpha})`);
          g.addColorStop(1, "rgba(15,23,42,0)");
          ctx.fillStyle = g;
          ctx.beginPath();
          ctx.arc(b.x, b.y, r, 0, Math.PI * 2);
          ctx.fill();
        }

        // è‡ªæœºå­å¼¹
        ctx.fillStyle = "#e0f2fe";
        for (const pb of playerBullets) {
          ctx.beginPath();
          ctx.arc(pb.x, pb.y, pb.r, 0, Math.PI * 2);
          ctx.fill();
        }

        // è‡ªæœºï¼šå¤–åœˆã€å°åˆ¤å®šç‚¹+æœºä½“ç®­å¤´æ„Ÿ
        // å¤–åœˆ
        ctx.beginPath();
        ctx.arc(player.x, player.y, player.drawRadius, 0, Math.PI * 2);
        ctx.fillStyle = "rgba(56, 189, 248, 0.22)";
        ctx.fill();

        // åˆ¤å®šç‚¹
        ctx.beginPath();
        ctx.arc(player.x, player.y, player.hitRadius, 0, Math.PI * 2);
        ctx.fillStyle = "#38bdf8";
        ctx.fill();

        // æœºä½“å°ä¸‰è§’
        ctx.beginPath();
        ctx.moveTo(player.x, player.y - player.drawRadius + 2);
        ctx.lineTo(player.x - player.drawRadius / 1.4, player.y + player.drawRadius / 1.2);
        ctx.lineTo(player.x + player.drawRadius / 1.4, player.y + player.drawRadius / 1.2);
        ctx.closePath();
        ctx.strokeStyle = "rgba(148, 163, 184, 0.9)";
        ctx.lineWidth = 1;
        ctx.stroke();

        // HUD æ–‡æœ¬
        ctx.fillStyle = "#e5e7eb";
        ctx.font = "13px system-ui, -apple-system, BlinkMacSystemFont, sans-serif";
        ctx.textAlign = "left";

        const timeStr = timeAlive.toFixed(1);
        const bestStr = bestTime.toFixed(1);

        ctx.fillText(`Time: ${timeStr}s`, 10, height - 56);
        ctx.fillText(`Best: ${bestStr}s`, 10, height - 38);
        ctx.fillText(`Grazes: ${grazes}`, 10, height - 20);

        ctx.textAlign = "right";
        ctx.fillText(`Best Grazes: ${bestGrazes}`, width - 10, height - 20);
        ctx.fillText(`Bombs: ${bombs}`, width - 10, height - 38);

        // ç‚¸å¼¹é«˜äº®
        if (bombActive || bombFlash > 0) {
          const alpha = bombActive ? 0.28 : bombFlash * 0.5;
          const g = ctx.createRadialGradient(
            player.x,
            player.y,
            0,
            player.x,
            player.y,
            Math.max(width, height)
          );
          g.addColorStop(0, `rgba(59, 130, 246, ${alpha})`);
          g.addColorStop(1, "rgba(15, 23, 42, 0)");
          ctx.fillStyle = g;
          ctx.fillRect(0, 0, width, height);
        }

        // æœªå¼€å§‹ / è¢«å‡»ä¸­æç¤º
        if (!playing) {
          ctx.fillStyle = "rgba(15,23,42,0.78)";
          ctx.fillRect(0, height / 2 - 44, width, 88);

          ctx.fillStyle = "#e5e7eb";
          ctx.textAlign = "center";
          ctx.font = "16px system-ui, -apple-system, BlinkMacSystemFont, sans-serif";
          const msg =
            timeAlive === 0
              ? "æŒ‰â€œå¼€å§‹ / é‡æ¥â€è¿›å…¥å¼¹å¹•ç»ƒä¹ "
              : "è¢«å‡»ä¸­äº†ï¼å†æŒ‘æˆ˜ä¸€æŠŠï¼Ÿ";
          ctx.fillText(msg, width / 2, height / 2 - 4);

          ctx.font = "13px system-ui, -apple-system, BlinkMacSystemFont, sans-serif";
          ctx.fillText(
            "â†‘â†“â†â†’ ç§»åŠ¨ Â· Shift ä½é€Ÿ Â· Z å°„å‡» Â· X Bomb",
            width / 2,
            height / 2 + 18
          );
        }
      }

      function loop(timestamp) {
        if (!lastTime) lastTime = timestamp;
        const dt = (timestamp - lastTime) / 16.67; // ä»¥ 60fps ä¸ºåŸºå‡†
        lastTime = timestamp;

        update(dt);
        draw();
        requestAnimationFrame(loop);
      }

      // é”®ç›˜äº‹ä»¶ï¼šæ‹¦æˆªæ–¹å‘é”®æ»šåŠ¨ã€å¤„ç† Z / X / Shift
      window.addEventListener("keydown", (e) => {
        const mapped = keyMap[e.key];
        if (["ArrowLeft", "ArrowRight", "ArrowUp", "ArrowDown"].includes(e.key)) {
          e.preventDefault(); // ä¸è®©é¡µé¢è·Ÿç€æ»šåŠ¨
        }
        if (!mapped) return;

        keys[mapped] = true;

        if (mapped === "x" && playing) {
          activateBomb();
        }
      });

      window.addEventListener("keyup", (e) => {
        const mapped = keyMap[e.key];
        if (!mapped) return;
        keys[mapped] = false;
      });

      document.getElementById("start-btn").addEventListener("click", () => {
        resetGame();
      });

      // åˆå§‹ç»˜åˆ¶ + å¾ªç¯
      draw();
      requestAnimationFrame(loop);
    })();
  </script>
</body>
</html>