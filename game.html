<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <title>å°æ¸¸æˆ | æœˆä¹‹æ£®çš„é»„ç“œæ¶</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="stylesheet" href="style.css" />
</head>
<body>
  <canvas id="bg-canvas"></canvas>

  <header class="site-header">
    <div class="container navbar">
      <a href="index.html" class="logo">æœˆã®æ£®<span>ğŸ¥’</span></a>
      <nav class="nav-links">
        <a href="index.html" class="nav-link">ä¸»é¡µ</a>
        <a href="about.html" class="nav-link">å…³äºæˆ‘</a>
        <a href="projects.html" class="nav-link">é¡¹ç›®</a>
        <a href="contact.html" class="nav-link">è”ç³»</a>
	<a href="game.html" class="nav-link active">å°æ¸¸æˆ</a>
      </nav>
    </div>
  </header>


  <main class="container">
    <section>
      <h1 class="section-title">å¼¹å¹•ç»ƒä¹ </h1>
      <p class="section-subtitle">
        æ“ä½œï¼šâ†‘ â†“ â† â†’ ç§»åŠ¨<br />
        æŒ‰ä½ <strong>Shift</strong> ä½é€Ÿå¾®è°ƒï¼Œ<strong>Z</strong> è¿å°„ï¼Œ<strong>X</strong> Bomb æ¸…å±ï¼‹çŸ­æš‚æ— æ•Œã€‚<br />

      </p>

      <div class="game-wrapper">
        <!-- ç«–ç‰ˆ STG æ¯”ä¾‹ -->
        <canvas id="game-canvas" width="360" height="480"></canvas>

        <div class="btn-row" style="margin-top: 0.75rem;">
          <button id="start-btn" class="btn btn-primary" type="button">
            å¼€å§‹ / é‡æ¥
          </button>
        </div>

        <p class="section-subtitle" style="margin-top: 0.6rem;">
          å°åœ†ç‚¹å°±æ˜¯ä½ ï¼Œé¡¶éƒ¨é‚£å›¢å…‰æ˜¯æ•Œæœºã€‚<br />

        </p>
      </div>
    </section>
  </main>

  <footer class="site-footer">
    <div class="container">
      Â© 2025 æœˆä¹‹æ£®çš„é»„ç“œæ¶ Â· Bullet Practice
    </div>
  </footer>

  <!-- ç²’å­èƒŒæ™¯ -->
  <script src="particles.js"></script>

  <!-- å¼¹å¹• + éç¬¦/ç¬¦å¡åºåˆ— + Z å°„å‡» + X ç‚¸å¼¹ -->
  <script>
    (function () {
      const canvas = document.getElementById("game-canvas");
      const ctx = canvas.getContext("2d");

      const width = canvas.width;
      const height = canvas.height;

      // é˜¶æ®µé…ç½®ï¼šéç¬¦1 â†’ ç¬¦1 â†’ éç¬¦2 â†’ ç¬¦2 â†’ éç¬¦3 â†’ ç»ˆç¬¦
      const PHASES = [
        {
          id: "ns1",
          title: "",
          type: "nonspell",
          hp: 400,
          delayMin: 70,
          delayMax: 90
        },
        {
          id: "spell1",
          title: "æ˜Ÿç¬¦ã€Œæ˜Ÿç²’æ•£å°„ã€",
          type: "spell",
          hp: 1000,
          delayMin: 60,
          delayMax: 80
        },
        {
          id: "ns2",
          title: "",
          type: "nonspell",
          hp: 400,
          delayMin: 65,
          delayMax: 85
        },
        {
          id: "spell2",
          title: "æ˜Ÿç¬¦ã€Œæ˜Ÿè½¨è½»æ‰‡ã€",
          type: "spell",
          hp: 1100,
          delayMin: 55,
          delayMax: 75
        },
        {
          id: "ns3",
          title: "",
          type: "nonspell",
          hp: 500,
          delayMin: 60,
          delayMax: 80
        },
        {
          id: "final",
          title: "ã€Œç¼“è¡Œèºæ—‹æ˜Ÿé›¨ã€",
          type: "spell",
          hp: 1100,
          delayMin: 50,
          delayMax: 70
        }
      ];
      const TOTAL_PHASES = PHASES.length;

      // è‡ªæœº
      const player = {
        x: width / 2,
        y: height - 70,
        hitRadius: 3,    // åˆ¤å®šç‚¹åŠå¾„
        drawRadius: 9,   // å¤–åœˆæ˜¾ç¤º
        baseSpeed: 3.6
      };

      // é”®ç›˜çŠ¶æ€
      const keys = {
        left: false,
        right: false,
        up: false,
        down: false,
        shift: false,
        z: false,
        x: false
      };

      const keyMap = {
        ArrowLeft: "left",
        ArrowRight: "right",
        ArrowUp: "up",
        ArrowDown: "down",
        Shift: "shift",
        z: "z",
        Z: "z",
        x: "x",
        X: "x"
      };

      // Boss
      const boss = {
        x: width / 2,
        y: 90,
        radius: 26,
        phaseIndex: 0,
        maxHp: PHASES[0].hp,
        hp: PHASES[0].hp,
        dir: 1,
        moveSpeed: 0.6,
        alive: true
      };

      let currentPhase = PHASES[0];

      // å¼¹å¹•ã€è‡ªæœºå­å¼¹
      const enemyBullets = [];
      const playerBullets = [];

      // æ¸¸æˆçŠ¶æ€
      let lastTime = 0;
      let timeAlive = 0;
      let bestTime = 0;
      let grazes = 0;
      let bestGrazes = 0;
      let playing = false;

      let patternTimer = 0;
      let spiralAngle = 0;
      let shootCooldown = 0;

      const grazeRadius = 22;

      // ç‚¸å¼¹
      let bombs = 3;
      let bombActive = false;
      let bombTimer = 0;
      let bombFlash = 0;
      const BOMB_DURATION = 120; // çº¦ 2 ç§’ï¼ˆ60fpsï¼‰

      // é˜¶æ®µæ ‡é¢˜æ˜¾ç¤ºç”¨
      let phaseLabelTimer = 0; // å€’è®¡æ—¶ï¼Œç”¨äºæ¸éš
      let gameOverReason = ""; // "", "hit", "clear"

      function randomDelayForPhase() {
        return (
          currentPhase.delayMin +
          Math.random() * (currentPhase.delayMax - currentPhase.delayMin)
        );
      }

      function resetBoss() {
        boss.x = width / 2;
        boss.y = 90;
        boss.radius = 26;
        boss.dir = 1;
        boss.moveSpeed = 0.6;
        boss.phaseIndex = 0;
        currentPhase = PHASES[0];
        boss.maxHp = currentPhase.hp;
        boss.hp = boss.maxHp;
        boss.alive = true;
      }

      function showPhaseLabel() {
        phaseLabelTimer = 120; // å¤§çº¦ 2 ç§’
      }

      function resetGame() {
        player.x = width / 2;
        player.y = height - 70;

        enemyBullets.length = 0;
        playerBullets.length = 0;

        timeAlive = 0;
        grazes = 0;
        patternTimer = 0;
        spiralAngle = 0;
        shootCooldown = 0;

        bombs = 3;
        bombActive = false;
        bombTimer = 0;
        bombFlash = 0;

        gameOverReason = "";

        resetBoss();
        showPhaseLabel();
        patternTimer = randomDelayForPhase();
        playing = true;
      }

      // æ•Œæœºå¼¹ï¼šåœ†å½¢ï¼ˆé»˜è®¤ï¼‰
      function createEnemyBullet(cx, cy, angle, speed) {
        const r = 4.5 + Math.random() * 1.4;
        const hue = 190 + Math.random() * 100;
        return {
          x: cx,
          y: cy,
          vx: Math.cos(angle) * speed,
          vy: Math.sin(angle) * speed,
          r,
          baseR: r,
          hue,
          alpha: 0.9,
          grazed: false,
          shape: "circle"
        };
      }

      // è‡ªæœºå­å¼¹ï¼šä¸¤è¡Œç›´ç›´å‘å‰ï¼ˆä¸å†åˆ†å‰ï¼‰
      function shootPlayerBullets() {
        const speed = 5.2;
        const vx = 0;
        const vy = -speed;
        const offset = 5; // å·¦å³å„ä¸€è¡Œ

        const bullets = [
          { x: player.x - offset, y: player.y - 4 },
          { x: player.x + offset, y: player.y - 4 }
        ];

        for (const p of bullets) {
          playerBullets.push({
            x: p.x,
            y: p.y,
            vx,
            vy,
            r: 3,
            damage: 3
          });
        }
      }

      function activateBomb() {
        if (!playing || bombs <= 0) return;
        bombs -= 1;
        bombActive = true;
        bombTimer = BOMB_DURATION;
        bombFlash = 1;
        enemyBullets.length = 0; // æ¸…å±
      }

      // ------------- å„é˜¶æ®µå¼¹å¹•æ¨¡å¼ -------------

      // éç¬¦1ï¼šç®€å•æ˜Ÿç²’åœˆ + å¶å°”æ‰å‡ é¢—å¤§æ˜Ÿç²’
      function patternNonspell1(cx, cy) {
        const count = 12;
        const baseSpeed = 1.0;
        for (let i = 0; i < count; i++) {
          const angle = (i / count) * Math.PI * 2;
          const b = createEnemyBullet(
            cx,
            cy,
            angle,
            baseSpeed + (Math.random() - 0.5) * 0.2
          );
          b.r *= 0.85;
          b.baseR = b.r;
          enemyBullets.push(b);
        }

        // å¶å°”æ¥ä¸€é¢—ç¨å¤§ä¸€ç‚¹çš„ä¸­é€Ÿå¼¹ä»ä¸Šå¾€ä¸‹å‹
        if (Math.random() < 0.7) {
          const x = 40 + Math.random() * (width - 80);
          const angle = Math.PI / 2;
          const speed = 1.1 + Math.random() * 0.2;
          const big = createEnemyBullet(x, cy, angle, speed);
          big.r *= 1.6;
          big.baseR = big.r;
          enemyBullets.push(big);
        }
      }

      // éç¬¦2ï¼šç•¥çª„æ‰‡å½¢ + å°‘é‡ç›´çº¿è½å¼¹
      function patternNonspell2(cx, cy) {
        const count = 9;
        const spread = Math.PI * 0.6;
        const baseAngle = Math.PI / 2;
        const baseSpeed = 1.05;

        for (let i = 0; i < count; i++) {
          const t = i / (count - 1) - 0.5;
          const angle = baseAngle + t * spread;
          const b = createEnemyBullet(
            cx,
            cy,
            angle,
            baseSpeed + (Math.random() - 0.5) * 0.15
          );
          b.r *= 0.9;
          b.baseR = b.r;
          enemyBullets.push(b);
        }

        // ä¸¤é¢—æ…¢é€Ÿç›´çº¿å¼¹ï¼Œç»™ä¸€ç‚¹çºµå‘å‹è¿«æ„Ÿ
        for (let k = 0; k < 2; k++) {
          const x = width * (0.25 + 0.5 * k) + (Math.random() - 0.5) * 30;
          const angle = Math.PI / 2;
          const speed = 1.0 + Math.random() * 0.4;
          const mid = createEnemyBullet(x, cy, angle, speed);
          mid.r *= 1.2;
          mid.baseR = mid.r;
          enemyBullets.push(mid);
        }
      }

      // éç¬¦3ï¼šç®€åŒ–ç‰ˆèºæ—‹ + å°‘é‡é›¨ç‚¹
      function patternNonspell3(cx, cy) {
        const speed = 1.05;
        // ä¸¤æ¡å¯¹ç§°èºæ—‹ï¼Œå­å¼¹ä¸å¤š
        for (let k = 0; k < 2; k++) {
          const angle = spiralAngle + k * Math.PI;
          const b = createEnemyBullet(cx, cy, angle, speed);
          b.r *= 1.0;
          b.baseR = b.r;
          enemyBullets.push(b);
        }
        spiralAngle += 0.25;

        // å‡ é¢—æ…¢é€Ÿç›´è½å°é›¨ç‚¹
        const drops = 3;
        for (let i = 0; i < drops; i++) {
          const x = 40 + Math.random() * (width - 80);
          const angle = Math.PI / 2;
          const v = 1.0 + Math.random() * 0.2;
          const d = createEnemyBullet(x, cy, angle, v);
          d.r *= 0.8;
          d.baseR = d.r;
          enemyBullets.push(d);
        }
      }

      // ç¬¦1ï¼šæ˜Ÿç¬¦ã€Œæ˜Ÿç²’æ•£å°„ã€
      // å…ˆå¿«åæ…¢çš„ä¸­ç‰ï¼Œæ··åˆè§„å¾‹å°ç‰å’Œéšæœºå¤§ç‰
      function patternSpell1(cx, cy) {
        const hpRatio = boss.hp / boss.maxHp;
        const fastPhase = hpRatio > 0.5;

        const midCount = 18;
        const midBaseSpeed = fastPhase ? 1.6 : 1.0;

        // ä¸­ç‰ç¯
        for (let i = 0; i < midCount; i++) {
          const angle = (i / midCount) * Math.PI * 2;
          const b = createEnemyBullet(
            cx,
            cy,
            angle,
            midBaseSpeed + (Math.random() - 0.5) * 0.24
          );
          b.r *= 1.5;
          b.baseR = b.r;
          enemyBullets.push(b);
        }

        // æœ‰è§„å¾‹çš„å°ç‰ï¼šå‘ä¸‹çš„çª„æ‰‡å½¢ä¸‰åˆ—
        const smallSpread = 0.35;
        const baseAngle = Math.PI / 2;
        for (let j = -1; j <= 1; j++) {
          const angle = baseAngle + j * smallSpread;
          const sb = createEnemyBullet(
            cx,
            cy,
            angle,
            1.15 + (fastPhase ? 0.15 : 0)
          );
          sb.r *= 0.7;
          sb.baseR = sb.r;
          enemyBullets.push(sb);
        }

        // æ— è§„å¾‹çš„å¤§ç‰ï¼šéšæœºæ–¹å‘å‡ é¢—
        const bigCount = fastPhase ? 2 : 3;
        for (let k = 0; k < bigCount; k++) {
          const angle = Math.random() * Math.PI * 2;
          const speed = fastPhase
            ? 1.4 + Math.random() * 0.3
            : 0.9 + Math.random() * 0.25;
          const big = createEnemyBullet(cx, cy, angle, speed);
          big.r *= 2.5;
          big.baseR = big.r;
          enemyBullets.push(big);
        }
      }

      // çŸ©å½¢å¼¹ï¼ˆé£ç¥å¾·æ„Ÿï¼‰
      function spawnRectFan(cx, cy, lanes, speed) {
        const spread = Math.PI * 0.9;
        const baseAngle = Math.PI / 2; // æœä¸‹
        for (let i = 0; i < lanes; i++) {
          const t = i / (lanes - 1) - 0.5;
          const angle = baseAngle + t * spread;
          const vx = Math.cos(angle) * speed;
          const vy = Math.sin(angle) * speed;

          enemyBullets.push({
            x: cx,
            y: cy,
            vx,
            vy,
            w: 12,
            h: 12,
            hue: 190 + t * 40,
            alpha: 0.95,
            grazed: false,
            shape: "rect"
          });
        }
      }

      // ç¬¦2ï¼šæ˜Ÿç¬¦ã€Œæ˜Ÿè½¨è½»æ‰‡ã€
      // é£ç¥å¾·é£æ ¼ï¼šé•¿æ–¹å½¢å°ç¬¦å¼¹æ‰‡å½¢
      function patternSpell2(cx, cy) {
        const hpRatio = boss.hp / boss.maxHp;
        const lanes = hpRatio > 0.5 ? 8 : 10;
        const speed = hpRatio > 0.5 ? 1.75 : 1.5;
        spawnRectFan(cx, cy, lanes, speed);

        // è¾¹ç¼˜å†åŠ ä¸¤æ¡ç•¥åä¸€ç‚¹çš„å­å¼¹è½¨è¿¹
        const sideOffset = 60;
        for (let side = -1; side <= 1; side += 2) {
          const x = cx + side * sideOffset;
          const angle = Math.PI / 2 + side * 0.15;
          const v = speed * 0.95;
          enemyBullets.push({
            x,
            y: cy,
            vx: Math.cos(angle) * v,
            vy: Math.sin(angle) * v,
            w: 5,
            h: 16,
            hue: 210 + side * 10,
            alpha: 0.9,
            grazed: false,
            shape: "rect"
          });
        }
      }

      // ç»ˆç¬¦ï¼šç¼“è¡Œèºæ—‹æ˜Ÿé›¨
      // æ…¢é€Ÿä½†è¾ƒå¯†çš„èºæ—‹ + å‚ç›´æ˜Ÿé›¨
      function patternFinal(cx, cy) {
        const ringCount = 20;
        const baseSpeed = 1.0;

        // èºæ—‹åœˆ
        for (let i = 0; i < ringCount; i++) {
          const angle = spiralAngle + (i / ringCount) * Math.PI * 2;
          const b = createEnemyBullet(cx, cy, angle, baseSpeed);
          b.r *= 1.1;
          b.baseR = b.r;
          enemyBullets.push(b);
        }
        spiralAngle += 0.22;

        // å‚ç›´æ˜Ÿé›¨ï¼šå¤šæ¡æ…¢é€Ÿç«–ç›´çº¿
        const lanes = 4;
        for (let i = 0; i < lanes; i++) {
          const x =
            40 +
            ((width - 80) * (i + 0.5)) / lanes +
            (Math.random() - 0.5) * 14;
          const angle = Math.PI / 2;
          const v = 1.05 + Math.random() * 0.15;
          const d = createEnemyBullet(x, cy, angle, v);
          d.r *= 0.85;
          d.baseR = d.r;
          enemyBullets.push(d);
        }
      }

      // æŒ‰å½“å‰ phase è§¦å‘å¯¹åº”æ¨¡å¼
      function spawnPatternForCurrentPhase() {
        const cx = boss.x;
        const cy = boss.y;
        switch (currentPhase.id) {
          case "ns1":
            patternNonspell1(cx, cy);
            break;
          case "spell1":
            patternSpell1(cx, cy);
            break;
          case "ns2":
            patternNonspell2(cx, cy);
            break;
          case "spell2":
            patternSpell2(cx, cy);
            break;
          case "ns3":
            patternNonspell3(cx, cy);
            break;
          case "final":
            patternFinal(cx, cy);
            break;
        }
      }

      function updateBoss(dt) {
        if (!boss.alive) return;

        // å·¦å³ç¼“æ…¢ç§»åŠ¨
        const moveAmount = boss.moveSpeed * dt;
        boss.x += moveAmount * boss.dir;

        const margin = 40;
        if (boss.x < margin) {
          boss.x = margin;
          boss.dir = 1;
        }
        if (boss.x > width - margin) {
          boss.x = width - margin;
          boss.dir = -1;
        }

        // å¼¹å¹•æ¨¡å¼å®šæ—¶
        patternTimer -= dt;
        if (patternTimer <= 0) {
          spawnPatternForCurrentPhase();
          patternTimer = randomDelayForPhase();
        }
      }

      function update(dt) {
        if (!playing) return;

        const speedFactor = dt;

        // è‡ªæœºç§»åŠ¨
        let speed = player.baseSpeed * speedFactor;
        if (keys.shift) speed *= 0.45;

        if (keys.left) player.x -= speed;
        if (keys.right) player.x += speed;
        if (keys.up) player.y -= speed;
        if (keys.down) player.y += speed;

        // è¾¹ç•Œ
        const margin = 12;
        if (player.x < margin) player.x = margin;
        if (player.x > width - margin) player.x = width - margin;
        if (player.y < margin) player.y = margin;
        if (player.y > height - margin) player.y = height - margin;

        // ç‚¸å¼¹è®¡æ—¶
        if (bombTimer > 0) {
          bombTimer -= dt;
          if (bombTimer <= 0) {
            bombTimer = 0;
            bombActive = false;
          }
        }
        if (bombFlash > 0) {
          bombFlash -= dt / BOMB_DURATION;
          if (bombFlash < 0) bombFlash = 0;
        }

        // å­˜æ´»æ—¶é—´
        timeAlive += dt / 60;

        // é˜¶æ®µæ ‡é¢˜è®¡æ—¶
        if (phaseLabelTimer > 0) {
          phaseLabelTimer -= dt;
          if (phaseLabelTimer < 0) phaseLabelTimer = 0;
        }

        // è‡ªæœºå°„å‡»
        if (shootCooldown > 0) {
          shootCooldown -= dt;
        }
        if (keys.z && shootCooldown <= 0) {
          shootPlayerBullets();
          shootCooldown = 6; // å¤§çº¦ 0.1 ç§’ä¸€è½®
        }

        // Boss / å¼¹å¹•
        updateBoss(dt);

        // æ•Œå¼¹æ›´æ–°ï¼ˆç§»åŠ¨ + å‘¼å¸ + æ“¦å¼¹ + åˆ¤å®šï¼‰
        for (const b of enemyBullets) {
          b.x += b.vx * speedFactor;
          b.y += b.vy * speedFactor;

          let size;
          if (b.shape === "rect") {
            size = Math.max(b.w, b.h) / 2;
          } else {
            const t = timeAlive * 3;
            b.r = b.baseR * (0.9 + 0.2 * Math.sin(t + b.hue));
            size = b.r;
          }

          const dx = b.x - player.x;
          const dy = b.y - player.y;
          const dist2 = dx * dx + dy * dy;

          const hitR = player.hitRadius + size * 0.8;
          const hitR2 = hitR * hitR;
          const grazeR = grazeRadius + size;
          const grazeR2 = grazeR * grazeR;

          if (!bombActive && dist2 < hitR2) {
            // è¢«å‡»ä¸­
            playing = false;
            gameOverReason = "hit";
            bestTime = Math.max(bestTime, timeAlive);
            bestGrazes = Math.max(bestGrazes, grazes);
            break;
          }

          if (!b.grazed && dist2 >= hitR2 && dist2 < grazeR2) {
            b.grazed = true;
            grazes += 1;
          }
        }

        // æ¸…ç†å‡ºç•Œå¼¹å¹•
        for (let i = enemyBullets.length - 1; i >= 0; i--) {
          const b = enemyBullets[i];
          if (
            b.x < -60 ||
            b.x > width + 60 ||
            b.y < -80 ||
            b.y > height + 80
          ) {
            enemyBullets.splice(i, 1);
          }
        }

        // è‡ªæœºå­å¼¹
        if (boss.alive) {
          for (let i = playerBullets.length - 1; i >= 0; i--) {
            const pb = playerBullets[i];
            pb.x += pb.vx * speedFactor;
            pb.y += pb.vy * speedFactor;

            if (pb.y < -40 || pb.y > height + 40) {
              playerBullets.splice(i, 1);
              continue;
            }

            const dx = pb.x - boss.x;
            const dy = pb.y - boss.y;
            const dist2 = dx * dx + dy * dy;
            const r = boss.radius + pb.r;

            if (dist2 < r * r) {
              boss.hp -= pb.damage;
              playerBullets.splice(i, 1);

              if (boss.hp <= 0) {
                // å½“å‰é˜¶æ®µå‡»ç ´
                boss.phaseIndex += 1;

                if (boss.phaseIndex < TOTAL_PHASES) {
                  // è¿›å…¥ä¸‹ä¸€é˜¶æ®µ
                  currentPhase = PHASES[boss.phaseIndex];
                  boss.maxHp = currentPhase.hp;
                  boss.hp = boss.maxHp;

                  enemyBullets.length = 0;
                  spiralAngle = 0;
                  patternTimer = 0;
                  showPhaseLabel();
                  patternTimer = randomDelayForPhase();
                } else {
                  // æ‰€æœ‰é˜¶æ®µæ‰“å®Œï¼šé€šå…³
                  boss.alive = false;
                  playing = false;
                  gameOverReason = "clear";
                  enemyBullets.length = 0;
                  bombActive = false;
                  bestTime = Math.max(bestTime, timeAlive);
                  bestGrazes = Math.max(bestGrazes, grazes);
                }
              }
            }
          }
        } else {
          // Boss å·²è¢«æ‰“å®Œï¼Œä¸å†ç”Ÿæˆå¼¹å¹•
        }
      }

      function draw() {
        // èƒŒæ™¯
        const grd = ctx.createLinearGradient(0, 0, 0, height);
        grd.addColorStop(0, "rgba(15,23,42,1)");
        grd.addColorStop(1, "rgba(15,23,42,0.96)");
        ctx.fillStyle = grd;
        ctx.fillRect(0, 0, width, height);

        ctx.fillStyle = "rgba(15, 23, 42, 0.16)";
        ctx.fillRect(0, 0, width, height);

        // Boss
        if (boss.alive) {
          const r = boss.radius * 1.8;
          const g = ctx.createRadialGradient(
            boss.x,
            boss.y,
            0,
            boss.x,
            boss.y,
            r
          );
          g.addColorStop(0, "rgba(251, 113, 133, 0.8)");
          g.addColorStop(1, "rgba(15, 23, 42, 0)");
          ctx.fillStyle = g;
          ctx.beginPath();
          ctx.arc(boss.x, boss.y, r, 0, Math.PI * 2);
          ctx.fill();

          ctx.beginPath();
          ctx.arc(boss.x, boss.y, boss.radius, 0, Math.PI * 2);
          ctx.fillStyle = "rgba(248, 250, 252, 0.95)";
          ctx.fill();

          ctx.fillStyle = "rgba(15, 23, 42, 0.9)";
          ctx.beginPath();
          ctx.arc(boss.x - 8, boss.y - 4, 3, 0, Math.PI * 2);
          ctx.arc(boss.x + 8, boss.y - 4, 3, 0, Math.PI * 2);
          ctx.fill();
        }

        // Boss è¡€æ¡
        if (boss.alive) {
          const barWidth = width - 40;
          const barHeight = 8;
          const x = 20;
          const y = 18;

          ctx.fillStyle = "rgba(15, 23, 42, 0.8)";
          ctx.fillRect(x, y, barWidth, barHeight);

          const ratio = boss.hp / boss.maxHp;
          const innerWidth = barWidth * Math.max(0, Math.min(1, ratio));

          const bg = ctx.createLinearGradient(x, y, x + barWidth, y);
          bg.addColorStop(0, "rgba(251, 113, 133, 0.9)");
          bg.addColorStop(1, "rgba(59, 130, 246, 0.9)");
          ctx.fillStyle = bg;
          ctx.fillRect(x, y, innerWidth, barHeight);

          ctx.strokeStyle = "rgba(148, 163, 184, 0.9)";
          ctx.lineWidth = 1;
          ctx.strokeRect(x + 0.5, y + 0.5, barWidth - 1, barHeight - 1);
        }

        // æ•Œå¼¹
        for (const b of enemyBullets) {
          if (b.shape === "rect") {
            ctx.fillStyle = `hsla(${b.hue}, 100%, 75%, ${b.alpha})`;
            ctx.fillRect(b.x - b.w / 2, b.y - b.h / 2, b.w, b.h);
          } else {
            const r = b.r * 2;
            const g = ctx.createRadialGradient(
              b.x,
              b.y,
              0,
              b.x,
              b.y,
              r
            );
            g.addColorStop(
              0,
              `hsla(${b.hue}, 100%, 75%, ${b.alpha})`
            );
            g.addColorStop(1, "rgba(15,23,42,0)");
            ctx.fillStyle = g;
            ctx.beginPath();
            ctx.arc(b.x, b.y, r, 0, Math.PI * 2);
            ctx.fill();
          }
        }

        // è‡ªæœºå­å¼¹
        ctx.fillStyle = "#e0f2fe";
        for (const pb of playerBullets) {
          ctx.beginPath();
          ctx.arc(pb.x, pb.y, pb.r, 0, Math.PI * 2);
          ctx.fill();
        }

        // è‡ªæœº
        ctx.beginPath();
        ctx.arc(player.x, player.y, player.drawRadius, 0, Math.PI * 2);
        ctx.fillStyle = "rgba(56, 189, 248, 0.22)";
        ctx.fill();

        ctx.beginPath();
        ctx.arc(player.x, player.y, player.hitRadius, 0, Math.PI * 2);
        ctx.fillStyle = "#38bdf8";
        ctx.fill();

        ctx.beginPath();
        ctx.moveTo(player.x, player.y - player.drawRadius + 2);
        ctx.lineTo(
          player.x - player.drawRadius / 1.4,
          player.y + player.drawRadius / 1.2
        );
        ctx.lineTo(
          player.x + player.drawRadius / 1.4,
          player.y + player.drawRadius / 1.2
        );
        ctx.closePath();
        ctx.strokeStyle = "rgba(148, 163, 184, 0.9)";
        ctx.lineWidth = 1;
        ctx.stroke();

        // HUD
        ctx.fillStyle = "#e5e7eb";
        ctx.font =
          "13px system-ui, -apple-system, BlinkMacSystemFont, sans-serif";
        ctx.textAlign = "left";

        const timeStr = timeAlive.toFixed(1);
        const bestStr = bestTime.toFixed(1);

        ctx.fillText(`Time: ${timeStr}s`, 10, height - 56);
        ctx.fillText(`Best: ${bestStr}s`, 10, height - 38);
        ctx.fillText(`Grazes: ${grazes}`, 10, height - 20);

        ctx.textAlign = "right";
        ctx.fillText(`Best Grazes: ${bestGrazes}`, width - 10, height - 20);
        ctx.fillText(`Bombs: ${bombs}`, width - 10, height - 38);

        // ç‚¸å¼¹é«˜äº®
        if (bombActive || bombFlash > 0) {
          const alpha = bombActive ? 0.28 : bombFlash * 0.5;
          const g = ctx.createRadialGradient(
            player.x,
            player.y,
            0,
            player.x,
            player.y,
            Math.max(width, height)
          );
          g.addColorStop(0, `rgba(59, 130, 246, ${alpha})`);
          g.addColorStop(1, "rgba(15, 23, 42, 0)");
          ctx.fillStyle = g;
          ctx.fillRect(0, 0, width, height);
        }

        // é˜¶æ®µæ ‡é¢˜ï¼ˆéç¬¦ / ç¬¦å¡ / ç»ˆç¬¦ï¼‰
        if (boss.alive && phaseLabelTimer > 0) {
          const alpha = Math.min(1, phaseLabelTimer / 60);
          ctx.save();
          ctx.globalAlpha = 0.4 + 0.6 * alpha;
          ctx.fillStyle = "#e5e7eb";
          ctx.textAlign = "center";
          ctx.font =
            "13px system-ui, -apple-system, BlinkMacSystemFont, sans-serif";
          ctx.fillText(
            `Phase ${boss.phaseIndex + 1}/${TOTAL_PHASES}`,
            width / 2,
            boss.y + boss.radius + 26
          );
          ctx.fillText(
            currentPhase.title,
            width / 2,
            boss.y + boss.radius + 44
          );
          ctx.restore();
        }

        // ç»“æŸ / å¼€å§‹æç¤º
        if (!playing) {
          ctx.fillStyle = "rgba(15,23,42,0.78)";
          ctx.fillRect(0, height / 2 - 48, width, 96);

          ctx.fillStyle = "#e5e7eb";
          ctx.textAlign = "center";
          ctx.font =
            "16px system-ui, -apple-system, BlinkMacSystemFont, sans-serif";

          let msg;
          if (timeAlive === 0 && gameOverReason === "") {
            msg = "æŒ‰â€œå¼€å§‹ / é‡æ¥â€è¿›å…¥å¼¹å¹•ç»ƒä¹ ";
          } else if (gameOverReason === "clear") {
            msg = "STAGE CLEAR! ç¬¦å¡å…¨ç ´ï¼";
          } else {
            msg = "è¢«å‡»ä¸­äº†ï¼å†æŒ‘æˆ˜ä¸€æŠŠï¼Ÿ";
          }
          ctx.fillText(msg, width / 2, height / 2 - 6);

          ctx.font =
            "13px system-ui, -apple-system, BlinkMacSystemFont, sans-serif";
          if (gameOverReason === "clear" && timeAlive > 0) {
            ctx.fillText(
              `ç”¨æ—¶ ${timeStr}s Â· æ“¦å¼¹ ${grazes}`,
              width / 2,
              height / 2 + 14
            );
            ctx.fillText(
              "â†‘â†“â†â†’ ç§»åŠ¨ Â· Shift ä½é€Ÿ Â· Z å°„å‡» Â· X Bomb",
              width / 2,
              height / 2 + 34
            );
          } else {
            ctx.fillText(
              "â†‘â†“â†â†’ ç§»åŠ¨ Â· Shift ä½é€Ÿ Â· Z å°„å‡» Â· X Bomb",
              width / 2,
              height / 2 + 18
            );
          }
        }
      }

      function loop(timestamp) {
        if (!lastTime) lastTime = timestamp;
        const dt = (timestamp - lastTime) / 16.67; // 60fps åŸºå‡†
        lastTime = timestamp;

        update(dt);
        draw();
        requestAnimationFrame(loop);
      }

      // é”®ç›˜äº‹ä»¶ï¼šæ‹¦æˆªæ–¹å‘é”®æ»šåŠ¨ + å¤„ç† Z / X / Shift
      window.addEventListener("keydown", (e) => {
        const mapped = keyMap[e.key];
        if (
          e.key === "ArrowLeft" ||
          e.key === "ArrowRight" ||
          e.key === "ArrowUp" ||
          e.key === "ArrowDown"
        ) {
          e.preventDefault();
        }
        if (!mapped) return;

        keys[mapped] = true;
        if (mapped === "x" && playing) {
          activateBomb();
        }
      });

      window.addEventListener("keyup", (e) => {
        const mapped = keyMap[e.key];
        if (!mapped) return;
        keys[mapped] = false;
      });

      document.getElementById("start-btn").addEventListener("click", () => {
        resetGame();
      });

      // åˆå§‹ç»˜åˆ¶ + å¾ªç¯
      draw();
      requestAnimationFrame(loop);
    })();
  </script>
</body>
</html>