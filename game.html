<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <title>小游戏 | 你的名字</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="stylesheet" href="style.css" />
</head>
<body>
  <canvas id="bg-canvas"></canvas>

  <header class="site-header">
    <div class="container navbar">
      <a href="index.html" class="logo">YOUR<span>NAME</span></a>
      <nav class="nav-links">
        <a href="index.html" class="nav-link">主页</a>
        <a href="about.html" class="nav-link">关于我</a>
        <a href="projects.html" class="nav-link">项目</a>
        <a href="contact.html" class="nav-link">联系</a>
	<a href="game.html" class="nav-link active">小游戏</a>
      </nav>
    </div>
  </header>

  <main class="container">
    <section>
      <h1 class="section-title">小小躲避游戏</h1>
      <p class="section-subtitle">
        用方向键移动你的方块，躲开从上面掉下来的障碍，看你能坚持多久！
      </p>

      <div class="game-wrapper">
        <canvas id="game-canvas" width="480" height="320"></canvas>

        <div class="btn-row" style="margin-top: 0.75rem;">
          <button id="start-btn" class="btn btn-primary" type="button">
            开始 / 重来
          </button>
        </div>

        <p class="section-subtitle" style="margin-top: 0.6rem;">
          操作：键盘 ↑ ↓ ← → 移动小方块；<br />
          灰蓝色小方块是你，斜着掉下来的深色块不要撞上。
        </p>
      </div>
    </section>
  </main>

  <footer class="site-footer">
    <div class="container">
      © 2025 你的名字 · Mini Game
    </div>
  </footer>

  <script src="particles.js"></script>

  <!-- 游戏脚本 -->
  <script>
    (function () {
      const canvas = document.getElementById("game-canvas");
      const ctx = canvas.getContext("2d");

      const width = canvas.width;
      const height = canvas.height;

      const player = {
        x: width / 2,
        y: height - 40,
        size: 16,
        speed: 3.4,
      };

      const keys = {
        ArrowLeft: false,
        ArrowRight: false,
        ArrowUp: false,
        ArrowDown: false,
      };

      let obstacles = [];
      let lastTime = 0;
      let spawnTimer = 0;
      let score = 0;
      let bestScore = 0;
      let playing = false;

      function resetGame() {
        player.x = width / 2;
        player.y = height - 40;
        obstacles = [];
        spawnTimer = 0;
        score = 0;
        playing = true;
      }

      function spawnObstacle() {
        const w = 20 + Math.random() * 40;
        const h = 14 + Math.random() * 26;
        const x = Math.random() * (width - w);
        const y = -h - 10;

        const speed = 2.2 + Math.random() * 2.0;
        const drift = (Math.random() - 0.5) * 0.8;

        obstacles.push({ x, y, w, h, speed, drift });
      }

      function update(dt) {
        if (!playing) return;

        // 移动玩家
        const move = player.speed * dt;
        if (keys.ArrowLeft) player.x -= move;
        if (keys.ArrowRight) player.x += move;
        if (keys.ArrowUp) player.y -= move;
        if (keys.ArrowDown) player.y += move;

        // 边界约束
        const s = player.size;
        if (player.x < s) player.x = s;
        if (player.x > width - s) player.x = width - s;
        if (player.y < s) player.y = s;
        if (player.y > height - s) player.y = height - s;

        // 生成障碍
        spawnTimer += dt;
        if (spawnTimer > 25) {
          spawnTimer = 0;
          spawnObstacle();
        }

        // 更新障碍位置
        obstacles.forEach((o) => {
          o.y += o.speed * dt;
          o.x += o.drift * dt;
        });

        // 删除出界障碍 & 加分
        obstacles = obstacles.filter((o) => {
          if (o.y > height + 40) {
            score += 1;
            return false;
          }
          return true;
        });

        // 碰撞检测
        for (const o of obstacles) {
          if (
            player.x + s > o.x &&
            player.x - s < o.x + o.w &&
            player.y + s > o.y &&
            player.y - s < o.y + o.h
          ) {
            playing = false;
            bestScore = Math.max(bestScore, score);
            break;
          }
        }
      }

      function draw() {
        ctx.clearRect(0, 0, width, height);

        // 背景
        const grd = ctx.createLinearGradient(0, 0, 0, height);
        grd.addColorStop(0, "rgba(15,23,42,0.9)");
        grd.addColorStop(1, "rgba(15,23,42,1)");
        ctx.fillStyle = grd;
        ctx.fillRect(0, 0, width, height);

        // 画玩家
        ctx.fillStyle = "#38bdf8";
        ctx.fillRect(
          player.x - player.size,
          player.y - player.size,
          player.size * 2,
          player.size * 2
        );

        // 画障碍
        ctx.fillStyle = "rgba(148, 163, 184, 0.95)";
        obstacles.forEach((o) => {
          ctx.fillRect(o.x, o.y, o.w, o.h);
        });

        // 文本
        ctx.fillStyle = "#e5e7eb";
        ctx.font = "13px system-ui, -apple-system, BlinkMacSystemFont, sans-serif";
        ctx.fillText(`Score: ${score}`, 12, 20);
        ctx.fillText(`Best: ${bestScore}`, 12, 38);

        if (!playing) {
          ctx.fillStyle = "rgba(15,23,42,0.75)";
          ctx.fillRect(0, height / 2 - 26, width, 48);

          ctx.fillStyle = "#e5e7eb";
          ctx.font = "16px system-ui, -apple-system, BlinkMacSystemFont, sans-serif";
          ctx.textAlign = "center";
          ctx.fillText(
            score === 0 ? "按“开始 / 重来”开始游戏" : "撞啦！再来一局？",
            width / 2,
            height / 2
          );
          ctx.textAlign = "left";
        }
      }

      function loop(timestamp) {
        if (!lastTime) lastTime = timestamp;
        const dt = (timestamp - lastTime) / 16.67; // 约等于帧数归一化
        lastTime = timestamp;

        update(dt);
        draw();
        requestAnimationFrame(loop);
      }

      window.addEventListener("keydown", (e) => {
        if (e.key in keys) {
          keys[e.key] = true;
        }
      });

      window.addEventListener("keyup", (e) => {
        if (e.key in keys) {
          keys[e.key] = false;
        }
      });

      document.getElementById("start-btn").addEventListener("click", () => {
        resetGame();
      });

      // 初次绘制
      draw();
      requestAnimationFrame(loop);
    })();
  </script>
</body>
</html>
